{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#curl-lib-for-orix","title":"curl lib for orix","text":"<p>It's a cc65 curl library for Orix</p>"},{"location":"#versions","title":"Versions","text":"<ul> <li>2026.1 documentation</li> </ul>"},{"location":"assembly/","title":"Assembly","text":""},{"location":"assembly/#assembly","title":"Assembly","text":""},{"location":"assembly/#curl_easy_cleanup","title":"curl_easy_cleanup","text":"<p>Description</p> <p>free ressources</p> <p>Input</p> <ul> <li>Accumulator : Low ptr</li> <li>X Register : High ptr</li> </ul>"},{"location":"assembly/#curl_easy_init","title":"curl_easy_init","text":"<p>Description</p> <p>Create curl struct</p> <p>Modify</p> <ul> <li>RESptr</li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : Low ptr curl struct</p> </li> <li> <p>Y Register : High ptr curl struct</p> </li> </ul>"},{"location":"assembly/#curl_easy_perform","title":"curl_easy_perform","text":"<p>Description</p> <p>Performs request</p> <p>Input</p> <ul> <li>Accumulator : Low ptr curl struct</li> <li>X Register : High ptr curl struct</li> </ul>"},{"location":"assembly/#curl_easy_setopt","title":"curl_easy_setopt","text":"<p>Description</p> <p>Set opt</p> <p>Input</p> <ul> <li>Accumulator : Low struct curl ptr</li> <li>X Register : High struct curl ptr</li> <li>Y Register : CURLOPT_URL </li> <li>RES : parameter </li> </ul> <p>Modify</p> <ul> <li>TR0Tmp</li> <li>TR1Tmp</li> <li>RESBPtr</li> </ul> <p>send CURLE_TOO_LARGE if the url parameter is bigger than lib curl can</p>"},{"location":"assembly/#curl_easy_strerror","title":"curl_easy_strerror","text":""},{"location":"assembly/#curl_parse_url","title":"curl_parse_url","text":""},{"location":"assembly/#curl_search_protocol","title":"curl_search_protocol","text":""},{"location":"assembly/#curl_print_object","title":"curl_print_object","text":"<p>jmp     curl_version endproc</p>"},{"location":"assembly/#curl_version","title":"curl_version","text":""},{"location":"c/","title":"C","text":""},{"location":"c/#c","title":"C","text":"<p>Description</p> <p>void curl_easy_cleanup(CURL *handle);</p>"},{"location":"c/#curl-curl_easy_init","title":"CURL *curl_easy_init();","text":"<p>Description</p> <p>CURLcode curl_easy_perform(CURL *easy_handle);</p> <p>const char str_ok[3] = \"OK\"; const char str_GET[6] = \"GET /\"; const char str_Host[7] = \"Host: \"; const char error_send[11] = \"send_error\"; const char str_timeout[6] = \"tmout\"; const char str_number_bytes[24] = \"Number bytes received: \"; const char str_content_length[17] = \"content-length: \"; Description</p> <p>CURLcode curl_easy_setopt(CURL *handle, CURLoption option, void parameter);</p> <p>Input</p> <p>Input</p> <p>Input</p> <p>Input</p> <p>;;@brief Set opt    ;;@inputA Low struct curl ptr    ;;@inputX High struct curl ptr    ;;@inputY CURLOPT_URL    ;;@inputMEM_RES  parameter    ;;@modifyMEM_TR0 Tmp    ;;@modifyMEM_TR1 Tmp    ;;@modifyMEM_RESB Ptr    ;;@note send CURLE_TOO_LARGE if the url parameter is bigger than lib curl can    sta     RESB    stx     RESB+1    sty     TR0    ldy     #curl_struct::curl_opt    lda     (RESB),y    eor     TR0    sta     (RESB),y    lda     TR0    cmp     #CURLOPT_VERBOSE    beq     @verbose_option    cmp     #CURLOPT_WRITEDATA    beq     @write_data_option    cmp     #CURLOPT_DRYRUN    beq     @dryrun_option    cmp     #CURLOPT_URL    beq     @url_option    ; Unknown option    lda     #CURLE_UNKNOWN_OPTION    rts write_data_option:    ; store fp    ldy     #curl_struct::curl_opt_ptr    lda     RES    sta     (RESB),y    iny    lda     RES+1    sta     (RESB),y    lda     #CURLE_OK    rts verbose_option:    print   verbose_option_str    lda     #CURLE_OK    rts dryrun_option:    lda     #curl_struct::curl_opt    lda     (RESB),y    and     #CURLOPT_VERBOSE    cmp     #CURLOPT_VERBOSE    bne     @not_verbose_dryrun    print   dryrun_option_str not_verbose_dryrun:    lda     #CURLE_OK    rts url_option:    lda     #curl_struct::url    sta     TR0    ldy     #$00 L1:    lda     (RES),y    beq     @out_copy_url    ; FIXME 65C02 TYX instead    sty     TR1    ldy     TR0    sta     (RESB),y    inc     TR0    ; FIXME 65C02 TXY instead    ldy     TR1    iny    cpy     #CURL_MAX_LENGTH_URL    bne     @L1    ; Error    lda     #CURLE_TOO_LARGE    rts out_copy_url:    ; Set eos    ldy     TR0    sta     (RESB),y    lda     #CURLE_OK    rts endproc</p> <p>const char supported_protocol_str[5] = \"http\"; const char str_curl_object[15] = \"Curl object : \"; const char str_hostname[13] = \" Hostname : \"; const char str_port[9] = \" Port : \"; const char str_ip_dest[7] = \" Ip : \"; const char str_uri[8] = \" Uri : \"; const char str_options[12] = \" Options : \"; const char str_CURLOPT_HEADER[16] = \"CURLOPT_HEADER \"; const char str_CURLOPT_WRITEDATA[19] = \"CURLOPT_WRITEDATA \";</p>"},{"location":"2024.1/assembly/","title":"Assembly","text":""},{"location":"2024.1/assembly/#assembly","title":"Assembly","text":""},{"location":"2024.1/assembly/#curl_easy_cleanup","title":"curl_easy_cleanup","text":""},{"location":"2024.1/assembly/#curl_easy_init","title":"curl_easy_init","text":"<p>Description</p> <p>Create curl struct</p> <p>Modify</p> <ul> <li>RESptr</li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : Low ptr curl struct</p> </li> <li> <p>Y Register : High ptr curl struct</p> </li> </ul>"},{"location":"2024.1/assembly/#curl_easy_perform","title":"curl_easy_perform","text":""},{"location":"2024.1/assembly/#curl_easy_setopt","title":"curl_easy_setopt","text":"<p>Description</p> <p>Set opt</p> <p>Input</p> <ul> <li>Accumulator : Low struct curl ptr</li> <li>X Register : High struct curl ptr</li> <li>Y Register : CURLOPT_URL </li> <li>RES : parameter </li> </ul> <p>Modify</p> <ul> <li>TR0Tmp</li> <li>RESBPtr</li> </ul>"},{"location":"2024.1/assembly/#curl_easy_strerror","title":"curl_easy_strerror","text":""},{"location":"2024.1/assembly/#curl_parse_url","title":"curl_parse_url","text":""},{"location":"2024.1/assembly/#curl_print_object","title":"curl_print_object","text":"<p>jmp     curl_version endproc</p>"},{"location":"2024.1/assembly/#curl_version","title":"curl_version","text":""},{"location":"2024.1/c/","title":"C","text":""},{"location":"2024.1/c/#c","title":"C","text":""},{"location":"2024.1/c/#curl-curl_easy_init","title":"CURL *curl_easy_init();","text":"<p>const char str_ok[3] = \"OK\"; const char str_GET[6] = \"GET /\"; const char str_Host[7] = \"Host: \"; const char error_send[11] = \"send_error\"; const char str_timeout[6] = \"tmout\"; const char str_number_bytes[24] = \"Number bytes received: \"; const char str_content_length[17] = \"content-length: \"; Description</p> <p>CURLcode curl_easy_setopt(CURL *handle, CURLoption option, void parameter);</p> <p>Input</p> <p>Input</p> <p>Input</p> <p>Input</p> <p>;;@brief Set opt    ;;@inputA Low struct curl ptr    ;;@inputX High struct curl ptr    ;;@inputY CURLOPT_URL    ;;@inputMEM_RES  parameter    ;;@modifyMEM_TR0 Tmp    ;;@modifyMEM_RESB Ptr    sta     RESB    stx     RESB+1    sty     TR0    ldy     #curl_struct::curl_opt    lda     (RESB),y    eor     TR0    sta     (RESB),y    lda     TR0    cmp     #CURLOPT_VERBOSE    beq     @verbose_option    cmp     #CURLOPT_WRITEDATA    beq     @write_data_option    cmp     #CURLOPT_DRYRUN    beq     @dryrun_option    cmp     #CURLOPT_URL    beq     @url_option    ; Unknown option    lda     #CURLE_UNKNOWN_OPTION    rts write_data_option:    ; store fp    ldy     #curl_struct::curl_opt_ptr    lda     RES    sta     (RESB),y    iny    lda     RES+1    sta     (RESB),y    lda     #CURLE_OK    rts verbose_option:    print   verbose_option_str    lda     #CURLE_OK    rts dryrun_option:    lda     #curl_struct::curl_opt    lda     (RESB),y    and     #CURLOPT_VERBOSE    cmp     #CURLOPT_VERBOSE    bne     @not_verbose_dryrun    print   dryrun_option_str not_verbose_dryrun:    lda     #CURLE_OK    rts url_option:    jsr     curl_parse_url    lda     #CURLE_OK    rts endproc</p> <p>const char str_curl_object[15] = \"Curl object : \"; const char str_hostname[13] = \" Hostname : \"; const char str_port[9] = \" Port : \"; const char str_ip_dest[7] = \" Ip : \"; const char str_uri[8] = \" Uri : \"; const char str_options[12] = \" Options : \"; const char str_CURLOPT_HEADER[16] = \"CURLOPT_HEADER \"; const char str_CURLOPT_WRITEDATA[19] = \"CURLOPT_WRITEDATA \";</p>"},{"location":"2024.2/assembly/","title":"Assembly","text":""},{"location":"2024.2/assembly/#assembly","title":"Assembly","text":""},{"location":"2024.2/assembly/#curl_easy_cleanup","title":"curl_easy_cleanup","text":"<p>Description</p> <p>free ressources</p> <p>Input</p> <ul> <li>Accumulator : Low ptr</li> <li>X Register : High ptr</li> </ul>"},{"location":"2024.2/assembly/#curl_easy_init","title":"curl_easy_init","text":"<p>Description</p> <p>Create curl struct</p> <p>Modify</p> <ul> <li>RESptr</li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : Low ptr curl struct</p> </li> <li> <p>Y Register : High ptr curl struct</p> </li> </ul>"},{"location":"2024.2/assembly/#curl_easy_perform","title":"curl_easy_perform","text":"<p>Description</p> <p>Performs request</p> <p>Input</p> <ul> <li>Accumulator : Low ptr curl struct</li> <li>X Register : High ptr curl struct</li> </ul>"},{"location":"2024.2/assembly/#curl_easy_setopt","title":"curl_easy_setopt","text":"<p>Description</p> <p>Set opt</p> <p>Input</p> <ul> <li>Accumulator : Low struct curl ptr</li> <li>X Register : High struct curl ptr</li> <li>Y Register : CURLOPT_URL </li> <li>RES : parameter </li> </ul> <p>Modify</p> <ul> <li>TR0Tmp</li> <li>TR1Tmp</li> <li>RESBPtr</li> </ul> <p>send CURLE_TOO_LARGE if the url parameter is bigger than lib curl can</p>"},{"location":"2024.2/assembly/#curl_easy_strerror","title":"curl_easy_strerror","text":""},{"location":"2024.2/assembly/#curl_parse_url","title":"curl_parse_url","text":""},{"location":"2024.2/assembly/#curl_search_protocol","title":"curl_search_protocol","text":""},{"location":"2024.2/assembly/#curl_print_object","title":"curl_print_object","text":"<p>jmp     curl_version endproc</p>"},{"location":"2024.2/assembly/#curl_version","title":"curl_version","text":""},{"location":"2024.2/c/","title":"C","text":""},{"location":"2024.2/c/#c","title":"C","text":"<p>Description</p> <p>void curl_easy_cleanup(CURL *handle);</p>"},{"location":"2024.2/c/#curl-curl_easy_init","title":"CURL *curl_easy_init();","text":"<p>Description</p> <p>CURLcode curl_easy_perform(CURL *easy_handle);</p> <p>const char str_ok[3] = \"OK\"; const char str_GET[6] = \"GET /\"; const char str_Host[7] = \"Host: \"; const char error_send[11] = \"send_error\"; const char str_timeout[6] = \"tmout\"; const char str_number_bytes[24] = \"Number bytes received: \"; const char str_content_length[17] = \"content-length: \"; Description</p> <p>CURLcode curl_easy_setopt(CURL *handle, CURLoption option, void parameter);</p> <p>Input</p> <p>Input</p> <p>Input</p> <p>Input</p> <p>;;@brief Set opt    ;;@inputA Low struct curl ptr    ;;@inputX High struct curl ptr    ;;@inputY CURLOPT_URL    ;;@inputMEM_RES  parameter    ;;@modifyMEM_TR0 Tmp    ;;@modifyMEM_TR1 Tmp    ;;@modifyMEM_RESB Ptr    ;;@note send CURLE_TOO_LARGE if the url parameter is bigger than lib curl can    sta     RESB    stx     RESB+1    sty     TR0    ldy     #curl_struct::curl_opt    lda     (RESB),y    eor     TR0    sta     (RESB),y    lda     TR0    cmp     #CURLOPT_VERBOSE    beq     @verbose_option    cmp     #CURLOPT_WRITEDATA    beq     @write_data_option    cmp     #CURLOPT_DRYRUN    beq     @dryrun_option    cmp     #CURLOPT_URL    beq     @url_option    ; Unknown option    lda     #CURLE_UNKNOWN_OPTION    rts write_data_option:    ; store fp    ldy     #curl_struct::curl_opt_ptr    lda     RES    sta     (RESB),y    iny    lda     RES+1    sta     (RESB),y    lda     #CURLE_OK    rts verbose_option:    print   verbose_option_str    lda     #CURLE_OK    rts dryrun_option:    lda     #curl_struct::curl_opt    lda     (RESB),y    and     #CURLOPT_VERBOSE    cmp     #CURLOPT_VERBOSE    bne     @not_verbose_dryrun    print   dryrun_option_str not_verbose_dryrun:    lda     #CURLE_OK    rts url_option:    lda     #curl_struct::url    sta     TR0    ldy     #$00 L1:    lda     (RES),y    beq     @out_copy_url    ; FIXME 65C02 TYX instead    sty     TR1    ldy     TR0    sta     (RESB),y    inc     TR0    ; FIXME 65C02 TXY instead    ldy     TR1    iny    cpy     #CURL_MAX_LENGTH_URL    bne     @L1    ; Error    lda     #CURLE_TOO_LARGE    rts out_copy_url:    ; Set eos    ldy     TR0    sta     (RESB),y    lda     #CURLE_OK    rts endproc</p> <p>const char supported_protocol_str[5] = \"http\"; const char str_curl_object[15] = \"Curl object : \"; const char str_hostname[13] = \" Hostname : \"; const char str_port[9] = \" Port : \"; const char str_ip_dest[7] = \" Ip : \"; const char str_uri[8] = \" Uri : \"; const char str_options[12] = \" Options : \"; const char str_CURLOPT_HEADER[16] = \"CURLOPT_HEADER \"; const char str_CURLOPT_WRITEDATA[19] = \"CURLOPT_WRITEDATA \";</p>"},{"location":"2026.1/","title":"curl lib (2026.1)","text":""},{"location":"2026.1/#curl-lib-20261","title":"curl lib (2026.1)","text":""},{"location":"2026.1/#usage-in-c-language","title":"Usage in c language","text":"<ul> <li>CURL *curl_easy_init();</li> <li>void curl_easy_cleanup(CURL *handle);</li> <li>void curl_easy_getinfo(CURL *curl, CURLINFO info, ... )</li> <li>CURLcode curl_easy_perform(CURL *easy_handle);</li> <li>URLcode curl_easy_setopt(CURL *handle, CURLoption option, void parameter);</li> <li>const char *curl_easy_strerror(CURLcode errornum);</li> <li>char *curl_version();</li> </ul>"},{"location":"2026.1/#usage-in-assembly-language","title":"Usage in assembly language","text":"<ul> <li>curl_easy_init</li> <li>curl_easy_cleanup</li> <li>curl_easy_getinfo</li> <li>curl_easy_perform</li> <li>curl_easy_setopt</li> <li>curl_easy_strerror</li> <li>curl_version</li> </ul>"},{"location":"2026.1/_curl_easy_cleanup/","title":"void curl_easy_cleanup(CURL *handle);","text":"<p>Description</p> <p>void curl_easy_cleanup(CURL *handle);</p> <p>Input</p> <ul> <li>handle The CURL handle to clean up. (This function is used to clean up a CURL handle that was previously initialized with curl_easy_init().)</li> </ul> <p>This function should be called when the handle is no longer needed to free up resources.</p> <p>This function is a no-op if the handle is NULL.</p> <p>Example</p> <pre><code> main() {\n CURL *curl;\n curl = curl_easy_init();\n curl_easy_cleanup(curl);\n }\n</code></pre>"},{"location":"2026.1/_curl_easy_getinfo/","title":"CURLcode easy_getinfo(CURL *curl, CURLINFO info, ... )","text":"<p>Description</p> <p>Get info from curl</p> <p>Input</p> <ul> <li>curl: The curl handle</li> <li>info: The info to get supported info : CURLINFO_PROTOCOL, CURLINFO_SCHEME, CURLINFO_PRIMARY_PORT, CURLINFO_HOST</li> <li>...: The value to store the info in</li> </ul> <p>all parameters must be allocated before calling this function, because curl_easy_getinfo does not allocate memory for you. It means that if you want to get a string, you must allocate a buffer for it before calling this function (of the right size).</p> <p>For CURLINFO_PROTOCOL ( unsigned char ), it can return one of the following values: CURLPROTO_HTTP, CURLPROTO_DICT, CURLPROTO_FILE, CURLPROTO_FTP, CURLPROTO_FTPS, CURLPROTO_GOPHER, CURLPROTO_HTTPS, CURLPROTO_IMAP, CURLPROTO_IMAPS, CURLPROTO_LDAP, CURLPROTO_LDAPS, CURLPROTO_POP3, CURLPROTO_POP3S, CURLPROTO_RTMP, CURLPROTO_RTMPE, CURLPROTO_RTMPS, CURLPROTO_RTMPT, CURLPROTO_RTMPTE, CURLPROTO_RTMPTS, CURLPROTO_RTSP, CURLPROTO_SCP, CURLPROTO_SFTP, CURLPROTO_SMB, CURLPROTO_SMBS, CURLPROTO_SMTP, CURLPROTO_SMTPS, CURLPROTO_TELNET, CURLPROTO_TFTP, CURLPROTO_UNKNOWN</p> <p>For CURLINFO_SCHEME ( char * ), it can return one of the following strings: \"HTTP\", \"DICT\", \"FILE\", \"FTP\", \"FTPS\", \"GOPHER\", \"HTTPS\", \"IMAP\", \"IMAPS\", \"LDAP\", \"LDAPS\", \"POP3\", \"POP3S\", \"RTMP\", \"RTMPE\", \"RTMPS\", \"RTMPT\", \"RTMPTE\", \"RTMPTS\", \"RTSP\", \"SCP\", \"SFTP\", \"SMB\", \"SMBS\", \"SMTP\", \"SMTPS\", \"TELNET\", \"TFTP\"</p> <p>for CURLINFO_PRIMARY_PORT, it returns the integer value of the port number used for the connection. eg : unsigned int port = 80;</p> <p>for CURLINFO_HOST, it returns the string value of the host name used for the connection. eg : char *host = \"example.com\";</p> <p>Example</p> <pre><code> main() {\n CURL *curl;\n char *scheme = \"01234567\";\n char *url = \"http://192.168.1.77:80/10K.htm\";\n curl = curl_easy_init();\n res = curl_easy_setopt(curl, CURLOPT_URL, url);\n curl_easy_getinfo(curl, CURLINFO_SCHEME, &amp;scheme);\n curl_easy_cleanup(curl);\n }\n</code></pre>"},{"location":"2026.1/_curl_easy_init/","title":"CURL *curl_easy_init();","text":"<p>Description</p> <p>init curl session and returns the initialization of the curl object</p> <p>Set default protocol to HTTP and default port to 80, hostname and uri to empty string, ip to 0.0.0.0</p> <p>Example</p> <pre><code> main() {\n CURL *curl;\n curl = curl_easy_init();\n curl_easy_cleanup(curl);\n }\n</code></pre>"},{"location":"2026.1/_curl_easy_perform/","title":"CURLcode curl_easy_perform(CURL *easy_handle);","text":"<p>Description</p> <p>Performs curl</p> <p>doest not work yet</p> <p>Input</p> <ul> <li>easy_handle: The curl handle</li> </ul>"},{"location":"2026.1/_curl_easy_setopt/","title":"URLcode curl_easy_setopt(CURL *handle, CURLoption option, void parameter);","text":"<p>Description</p> <p>set opt for curl object (Ex : res = curl_easy_setopt(curl, CURLOPT_URL, \"http://example)</p> <p>Input</p> <ul> <li>handle: The curl handle</li> <li>option: The option to set</li> <li>parameter: The parameter for the option Example</li> </ul> <pre><code> main() {\n CURL *curl;\n char *url = \"http://192.168.1.77:80/10K.htm\";\n curl = curl_easy_init();\n res = curl_easy_setopt(curl, CURLOPT_URL, url);\n curl_easy_cleanup(curl);\n }\n</code></pre>"},{"location":"2026.1/_curl_easy_strerror/","title":"const char *curl_easy_strerror(CURLcode errornum);","text":"<p>Description</p> <p>convert errornum into str</p> <p>Input</p> <ul> <li>errornum: The CURLcode error number Example</li> </ul> <pre><code> main() {\n CURL *curl;\n char *url = \"http://192.168.1.77:80/10K.htm\";\n curl = curl_easy_init();\n res = curl_easy_setopt(curl, CURLOPT_URL, url);\n printf(\"%s\\n\", curl_easy_strerror(res));\n curl_easy_cleanup(curl);\n }\n</code></pre>"},{"location":"2026.1/_curl_version/","title":"char *curl_version();","text":"<p>Description</p> <p>get curl version</p> <p>Example</p> <pre><code> main() {\n printf(\"Curl version: %s\\n\", curl_version());\n }\n</code></pre>"},{"location":"2026.1/atoi32/","title":"Atoi32","text":""},{"location":"2026.1/atoi32/#atoi32","title":"atoi32","text":"<p>Description</p> <p>convert a string into 32 bits integer</p> <p>Input</p> <ul> <li>X Register : Low ptr string</li> </ul> <p>Modify</p> <ul> <li>TR0</li> <li>TR1</li> <li>TR2</li> <li>TR3</li> <li>RES</li> </ul> <p>Returns</p>"},{"location":"2026.1/curl_easy_cleanup/","title":"curl_easy_cleanup","text":"<p>Description</p> <p>free curl ressources</p> <p>Input</p> <ul> <li>Accumulator : Low ptr of curl ressources</li> <li>X Register : High ptr of curl ressources</li> </ul> <p>Example</p> <pre><code> lda curl_handle_low ; ptr to curl handle\n ldx curl_handle_high ; ptr to curl handle\n jsr curl_easy_cleanup\n rts\n</code></pre>"},{"location":"2026.1/curl_easy_getinfo/","title":"curl_easy_getinfo","text":"<p>Description</p> <p>get infos from curl ressource</p> <p>Input</p> <ul> <li>Accumulator : Low ptr of curl ressource</li> <li>X Register : High ptr of curl ressource</li> <li>Y Register : Curl info to get ex : CURLINFO_PROTOCOL or CURLINFO_PRIMARY_PORT etc</li> </ul> <p>Modify</p> <ul> <li>RES</li> <li>RESB2 bytes (for output ptr)</li> <li>TR0</li> <li>TR22 bytes</li> </ul> <p>Example</p> <pre><code> lda ptr_parameter_low ; ptr to parameter\n sta RESB ; ptr to parameter\n lda ptr_parameter_high ; ptr to parameter\n sta RESB + 1 ; ptr to parameter\n lda curl_handle_low ; ptr to curl handle\n ldx curl_handle_high ; ptr to curl handle\n ldy CURLINFO_PROTOCOL ; info to get\n jsr curl_easy_cleanup\n rts\n</code></pre> <p>for CURLINFO_SCHEME, the parameter must be already allocated with enough space to store the string : 7 bytes</p> <p>for CURLINFO_PRIMARY_IP, the parameter must be already allocated with enough space to store the string : eg : 16 bytes (xxx.xxx.xxx.xxx + null terminator)</p> <p>returns CURLE_OK if ok, CURLE_UNKNOWN_OPTION if option unknown</p>"},{"location":"2026.1/curl_easy_init/","title":"curl_easy_init","text":"<p>Description</p> <p>Create curl struct (calls XMALLOC from kernel)</p> <p>Modify</p> <ul> <li>RESptr</li> </ul> <p>Returns</p> <ul> <li>Accumulator : Low ptr curl struct</li> <li>Y Register : High ptr curl struct</li> </ul> <p>Example</p> <pre><code> jsr curl_easy_init\n ; And X contains ptr to curl handle\n rts\n</code></pre> <p>Set default protocol to HTTP and default port to 80, hostname and uri to empty string, ip to 0.0.0.0</p>"},{"location":"2026.1/curl_easy_perform/","title":"curl_easy_perform","text":"<p>Description</p> <p>Performs request does not work yet</p> <p>Input</p> <ul> <li>Accumulator : Low ptr curl struct</li> <li>X Register : High ptr curl struct</li> </ul> <p>Modify</p> <ul> <li>REStemp</li> <li>RESB</li> <li>HRS3</li> <li>TR0</li> <li>TR1</li> <li>TR2</li> <li>TR3</li> <li>TR4</li> <li>TR5</li> <li>TR6</li> <li>TR7</li> </ul> <p>Returns</p> <ul> <li>Accumulator : CURLE_TOO_LARGE : Content length not found</li> </ul> <p>const char str_number_bytes[24] = \"Number bytes received: \";const char str_timeout[6] = \"tmout\";</p>"},{"location":"2026.1/curl_easy_setopt/","title":"curl_easy_setopt","text":"<p>Description</p> <p>Set opt</p> <p>Input</p> <ul> <li>Accumulator : Low struct curl ptr</li> <li>X Register : High struct curl ptr</li> <li>Y Register : CURLOPT option to set (CURLOPT_URL only handled)</li> <li>RES : parameter </li> </ul> <p>Modify</p> <ul> <li>TR0Tmp</li> <li>TR2saveY tmp</li> <li>TR3tmp</li> <li>HRStmp</li> <li>RESBPtr</li> </ul> <p>Example</p> <pre><code> jsr curl_easy_setopt\n rts\n</code></pre> <p>send CURLE_TOO_LARGE if the url parameter is bigger than lib curl can</p> <p>send CURLE_TOO_LARGE if the ** parameter is bigger than lib curl can (CURL_MAX_LENGTH_URI into curl.h)</p> <p>uses atoi from cc65 telestrat.lib instead of reimplementing it or calling it from orix kernel</p> <p>Handles only CURLOPT_URL option</p>"},{"location":"2026.1/curl_easy_strerror/","title":"curl_easy_strerror","text":"<p>Description</p> <p>Set opt</p> <p>Input</p> <ul> <li>Accumulator : id of the error</li> </ul> <p>Returns</p> <ul> <li>X Register : High struct curl ptr of the string error</li> </ul>"},{"location":"2026.1/curl_parse_url/","title":"Curl parse url","text":""},{"location":"2026.1/curl_parse_url/#curl_parse_url","title":"curl_parse_url","text":""},{"location":"2026.1/curl_parse_url/#curl_search_protocol","title":"curl_search_protocol","text":""},{"location":"2026.1/curl_print_object/","title":"Curl print object","text":""},{"location":"2026.1/curl_print_object/#curl_print_object","title":"curl_print_object","text":""},{"location":"2026.1/curl_version/","title":"curl_version","text":"<p>Description</p> <p>returns curl version</p>"}]}